// // Generated by CoffeeScript 1.3.3
// (function() {

//   this.getType = function(obj) {
//     return Object.prototype.toString.call(obj).match(/^\[object (.*)\]$/)[1];
//   };

//   this.getType = function(obj) {
//     var classToType, myClass, name, _i, _len, _ref;
//     if (obj === void 0 || obj === null) {
//       return String(obj);
//     }
//     classToType = new Object;
//     _ref = "Boolean Number String Function Array Date RegExp".split(" ");
//     for (_i = 0, _len = _ref.length; _i < _len; _i++) {
//       name = _ref[_i];
//       classToType["[object " + name + "]"] = name.toLowerCase();
//     }
//     myClass = Object.prototype.toString.call(obj);
//     if (myClass in classToType) {
//       return classToType[myClass];
//     }
//     return "object";
//   };

//   this.isNum = function(obj) {
//     return getType(obj) === 'number';
//   };

//   this.isString = function(obj) {
//     return getType(obj) === 'string';
//   };

//   this.isArray = function(obj) {
//     return getType(obj) === 'array';
//   };

//   if (!String.prototype.toSentenceCase) {
//     String.prototype.toSentenceCase = function() {
//       return this.charAt(0).toUpperCase() + this.slice(1);
//     };
//   }

//   if (!String.prototype.trim) {
//     String.prototype.trim(function() {
//       return this.replace(/^\s+|\s+$/g, '');
//     });
//   }

//   if (!Array.prototype.prod) {
//     Array.prototype.prod = function() {
//       var element, prod, _i, _len;
//       prod = 1;
//       for (_i = 0, _len = this.length; _i < _len; _i++) {
//         element = this[_i];
//         if (isNum(element)) {
//           prod *= element;
//         }
//       }
//       return prod;
//     };
//   }

//   if (!Array.prototype.sum) {
//     Array.prototype.sum = function() {
//       var element, sum, _i, _len;
//       sum = 0;
//       for (_i = 0, _len = this.length; _i < _len; _i++) {
//         element = this[_i];
//         if (isNum(element)) {
//           sum += element;
//         }
//       }
//       return sum;
//     };
//   }

//   if (!Array.prototype.mean) {
//     Array.prototype.mean = function() {
//       return this.sum() / this.length;
//     };
//   }

//   if (!Array.prototype.normalize) {
//     Array.prototype.normalize = function() {
//       var element, temp, total, _i, _len;
//       total = this.sum();
//       temp = [];
//       for (_i = 0, _len = this.length; _i < _len; _i++) {
//         element = this[_i];
//         element = 1.0 * element / total;
//         temp.push(element);
//       }
//       return temp;
//     };
//   }

//   if (!Array.prototype.isEmpty) {
//     Array.prototype.isEmpty = function() {
//       if (this.length > 0) {
//         return false;
//       } else {
//         return true;
//       }
//     };
//     if (!Array.prototype.remove) {
//       Array.prototype.remove = function(e) {
//         var t, _ref;
//         if ((t = this.indexOf(e)) > -1) {
//           return ([].splice.apply(this, [t, t - t + 1].concat(_ref = [])), _ref);
//         }
//       };
//     }
//   }

//   if (!Array.prototype.cumsum) {
//     Array.prototype.cumsum = function() {
//       var current_sum, element, idx, temp, _i, _len;
//       temp = zeros(this.length);
//       idx = 0;
//       current_sum = 0;
//       for (_i = 0, _len = this.length; _i < _len; _i++) {
//         element = this[_i];
//         current_sum += element;
//         temp[idx] = current_sum;
//         idx += 1;
//       }
//       return temp;
//     };
//   }

//   this.isEmpty = function(object) {
//     var prop;
//     for (prop in object) {
//       if (object.hasOwnProperty(prop)) {
//         return false;
//       }
//     }
//     return true;
//   };

//   this.zeros = function(N) {
//     var iter, zeros, _i;
//     zeros = [];
//     for (iter = _i = 0; 0 <= N ? _i < N : _i > N; iter = 0 <= N ? ++_i : --_i) {
//       zeros.push(0);
//     }
//     return zeros;
//   };

//   this.ones = function(N) {
//     var iter, ones, _i;
//     ones = [];
//     for (iter = _i = 0; 0 <= N ? _i < N : _i > N; iter = 0 <= N ? ++_i : --_i) {
//       ones.push(1);
//     }
//     return ones;
//   };

//   this.range = function(N) {
//     var iter, range, val, _i;
//     range = [];
//     val = 0;
//     for (iter = _i = 0; 0 <= N ? _i < N : _i > N; iter = 0 <= N ? ++_i : --_i) {
//       range.push(val);
//       val += 1;
//     }
//     return range;
//   };

//   this.intersect = function(x, y) {
//     var intersection, xx, yy, _i, _j, _len, _len1;
//     intersection = [];
//     for (_i = 0, _len = x.length; _i < _len; _i++) {
//       xx = x[_i];
//       for (_j = 0, _len1 = y.length; _j < _len1; _j++) {
//         yy = y[_j];
//         if (xx === yy) {
//           intersection.push(xx);
//         }
//       }
//     }
//     return intersection;
//   };

//   this.merge = function(a, b, a_key, b_key) {
//     var A, idx, obj, _i, _len, _ref;
//     if (a.length !== b.length) {
//       return null;
//     }
//     A = [];
//     idx = 0;
//     _ref = range(a.length);
//     for (_i = 0, _len = _ref.length; _i < _len; _i++) {
//       idx = _ref[_i];
//       obj = {};
//       obj[a_key] = a[idx];
//       obj[b_key] = b[idx];
//       A.push(obj);
//     }
//     return A;
//   };

//   this.circshift = function(a, delta) {
//     if (delta == null) {
//       delta = 1;
//     }
//     delta = -1 * (delta % a.length);
//     if (delta === 0) {
//       return a;
//     }
//     return a = a.slice(delta).concat(a.slice(0, (delta - 1) + 1 || 9e9));
//   };

//   if (!Array.prototype.contains) {
//     Array.prototype.contains = function(element) {
//       if (getType(element) !== 'array') {
//         element = [element];
//       }
//       if (intersect(this, element).length > 0) {
//         return true;
//       } else {
//         return false;
//       }
//     };
//   }

// }).call(this);
