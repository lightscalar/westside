// Generated by CoffeeScript 1.3.3
(function() {
  var Cortex,
    __hasProp = {}.hasOwnProperty;

  this.Cortex = Cortex = (function() {

    function Cortex(maxPrototypes, activationRadii, minLocs, learningRate, dims) {
      var key, value,
        _this = this;
      this.maxPrototypes = maxPrototypes;
      this.activationRadii = activationRadii;
      this.minLocs = minLocs;
      this.learningRate = learningRate;
      this.dims = dims;
      if (this.minLocs >= 3) {
        this.maxSimilarity = 1.0 - 1.0 / (this.minLocs - 1);
      } else {
        this.maxSimilarity = 0.5;
      }
      this.vectorDimension = ((function() {
        var _ref, _results;
        _ref = this.activationRadii;
        _results = [];
        for (key in _ref) {
          value = _ref[key];
          _results.push(key);
        }
        return _results;
      }).call(this)).length;
      this.prototypes = [];
      this.nPrototypes = 0;
      this.similarity = function(p1, p2) {
        var d, similarity, tmp;
        similarity = 1;
        for (key in p1) {
          if (key === '_value') {
            continue;
          }
          d = Math.abs(p1[key] - p2[key]);
          if (d < this.activationRadii[key]) {
            tmp = 1 - d / this.activationRadii[key];
            if (tmp <= similarity) {
              similarity = tmp;
            }
          } else {
            return 0;
          }
        }
        return similarity;
      };
      this.triangle = function(p1, p2) {
        return 1 / _this.similarity(p1, p2);
      };
      this.tree = new kdTree(this.prototypes, this.triangle, this.dims);
    }

    Cortex.prototype.add = function(state, value) {
      var activeSet, key, predictedValue, randomState, _results;
      if (((function() {
        var _results;
        _results = [];
        for (key in state) {
          _results.push(key);
        }
        return _results;
      })()).length !== this.vectorDimension) {
        throw 'Vector dimension must be ' + this.vectorDimension + '.';
      }
      if (this.sparseEnough(state)) {
        this.addPrototype(state, value);
        this.randState(state);
      }
      activeSet = this.activeSet(state);
      _results = [];
      while (activeSet.length < this.minLocs) {
        randomState = this.randState(state);
        predictedValue = this.predict(state);
        randomState._value = predictedValue;
        if (this.sparseEnough(randomState)) {
          this.addPrototype(randomState, predictedValue);
          _results.push(activeSet = this.activeSet(state));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Cortex.prototype.addPrototype = function(state, value) {
      if (this.nPrototypes >= this.maxPrototypes) {
        this.removePrototype();
      }
      state['_value'] = value;
      this.prototypes.push(state);
      this.nPrototypes += 1;
      this.updateTree();
      return this.updatePrototypes(state, value);
    };

    Cortex.prototype.updatePrototypes = function(state, value) {
      var activeSet, denom, p, predictedValue, _i, _j, _len, _len1, _results;
      predictedValue = this.predict(state);
      activeSet = this.activeSet(state);
      denom = 0;
      for (_i = 0, _len = activeSet.length; _i < _len; _i++) {
        p = activeSet[_i];
        denom += 1 / p[1];
      }
      _results = [];
      for (_j = 0, _len1 = activeSet.length; _j < _len1; _j++) {
        p = activeSet[_j];
        _results.push(p[0]._value = p[0]._value + this.learningRate / denom * (value - predictedValue));
      }
      return _results;
    };

    Cortex.prototype.randState = function(state) {
      var key, newState;
      newState = {};
      for (key in state) {
        if (!__hasProp.call(state, key)) continue;
        newState[key] = state[key] + 2 * (Math.random() - 0.5) * this.activationRadii[key];
      }
      return newState;
    };

    Cortex.prototype.predict = function(state) {
      var activeSet, denom, numer, p, _i, _len;
      if (this.nPrototypes === 0) {
        return 0;
      }
      activeSet = this.activeSet(state);
      if (activeSet.length === 0) {
        return 0;
      }
      denom = 0;
      numer = 0;
      for (_i = 0, _len = activeSet.length; _i < _len; _i++) {
        p = activeSet[_i];
        denom += 1 / p[1];
        numer += 1 / p[1] * p[0]._value;
      }
      return numer / denom;
    };

    Cortex.prototype.sparseEnough = function(state) {
      var nearestNeighbor;
      if (this.nPrototypes === 0) {
        return true;
      }
      nearestNeighbor = this.tree.nearest(state, 1, 100);
      if (nearestNeighbor.length === 0) {
        return true;
      }
      return this.similarity(state, nearestNeighbor) < this.maxSimilarity;
    };

    Cortex.prototype.removePrototype = function() {
      var key, nearestNeighbor, p, target, _i, _len;
      target = Math.floor(Math.random() * this.nPrototypes);
      p = this.prototypes[target];
      nearestNeighbor = this.tree.nearest(p, 1, 100);
      for (_i = 0, _len = p.length; _i < _len; _i++) {
        key = p[_i];
        nearestNeighbor[0][key] = (nearestNeighbor[0][key] + p[key]) / 2;
      }
      this.prototypes.remove(p);
      return this.nPrototypes -= 1;
    };

    Cortex.prototype.updateTree = function() {
      return this.tree = new kdTree(this.prototypes, this.triangle, this.dims);
    };

    Cortex.prototype.activeSet = function(state) {
      return this.tree.nearest(state, this.minLocs * 2, 100);
    };

    return Cortex;

  })();

}).call(this);
