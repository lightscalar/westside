// Generated by CoffeeScript 1.3.3
(function() {

  this.directives = angular.module('directives', []);

  this.directives.directive('introduction', function() {
    return {
      restrict: 'A',
      replace: true,
      template: '<div id="introduction"></div>',
      link: function(scope, element, attrs) {
        var R2, dblClick, distance, height, i, kdtree, maxNeighbors, nTick, nearestNeighbors, nodeClick, nodes, numMembers, p, players, rVisual, radius, resetSim, setSpeed, shouldWeStop, svg, tick, width, _i;
        shouldWeStop = true;
        resetSim = false;
        height = $(element).height();
        width = $(element).width();
        radius = 3;
        R2 = radius * radius;
        rVisual = 30;
        maxNeighbors = 15;
        Array.prototype.remove = function(e) {
          var t, _ref;
          if ((t = this.indexOf(e)) > -1) {
            return ([].splice.apply(this, [t, t - t + 1].concat(_ref = [])), _ref);
          }
        };
        setSpeed = function(p, targetSpeed) {
          var norm;
          norm = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
          p.vx = targetSpeed * p.vx / norm;
          p.vy = targetSpeed * p.vy / norm;
          return p;
        };
        distance = function(p1, p2) {
          return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        };
        numMembers = 50;
        players = [];
        for (i = _i = 0; 0 <= numMembers ? _i < numMembers : _i > numMembers; i = 0 <= numMembers ? ++_i : --_i) {
          p = {
            x: radius + Math.round(Math.random() * (width - 2 * radius)),
            y: radius + Math.round(Math.random() * (height - 2 * radius)),
            vx: Math.random(),
            vy: Math.random(),
            gang: Math.round(Math.random())
          };
          p = setSpeed(p, 2);
          players.push(p);
        }
        kdtree = new kdTree(players, distance, ['x', 'y']);
        nearestNeighbors = function(kdtree, node, R) {
          var neighbors;
          neighbors = kdtree.nearest(node, maxNeighbors, R);
          return neighbors;
        };
        nodeClick = function(node) {
          shouldWeStop = !shouldWeStop;
          if (!shouldWeStop) {
            return d3.timer(tick);
          }
        };
        dblClick = function() {
          resetSim = true;
          return d3.event.stopPropagation();
        };
        svg = d3.select('#introduction').insert('svg:svg').on('click', nodeClick).on('dblclick', dblClick);
        nodes = svg.selectAll('circle').data(players);
        nodes.enter().insert('circle').attr('cx', function(d) {
          return d.x;
        }).attr('cy', function(d) {
          return d.y;
        }).attr('class', function(d) {
          if (d.gang) {
            return 'shark';
          } else {
            return 'jet';
          }
        }).attr('r', radius);
        nodes.exit().remove;
        nTick = 0;
        tick = function() {
          var D2, centroidForceX, centroidForceY, coefs, cx, cy, directionForceX, directionForceY, enemies, friends, inertiaX, inertiaY, neighbor, neighbors, numEnemies, numFriends, numNeighbors, randomX, randomY, repulseX, repulseY, rx, ry, _j, _k, _l, _len, _len1, _len2;
          if (resetSim) {
            for (_j = 0, _len = players.length; _j < _len; _j++) {
              p = players[_j];
              p.x = radius + Math.round(Math.random() * (width - 2 * radius));
              p.y = radius + Math.round(Math.random() * (height - 2 * radius));
            }
            shouldWeStop = true;
            resetSim = false;
          }
          nTick += 1;
          for (_k = 0, _len1 = players.length; _k < _len1; _k++) {
            p = players[_k];
            cx = width / 2 - p.x;
            cy = height / 2 - p.y;
            neighbors = nearestNeighbors(kdtree, p, rVisual);
            numNeighbors = neighbors.length;
            numFriends = 0;
            numEnemies = 0;
            rx = 0;
            ry = 0;
            friends = {
              mvx: 0,
              mvy: 0,
              mx: 0,
              my: 0,
              rx: 0,
              ry: 0
            };
            enemies = {
              mvx: 0,
              mvy: 0,
              mx: 0,
              my: 0,
              rx: 0,
              ry: 0
            };
            for (_l = 0, _len2 = neighbors.length; _l < _len2; _l++) {
              neighbor = neighbors[_l];
              D2 = neighbor[1] * neighbor[1];
              if (neighbor[0].gang === p.gang) {
                numFriends += 1;
                friends.mvx += neighbor[0].vx;
                friends.mvy += neighbor[0].vy;
                friends.mx += neighbor[0].x;
                friends.my += neighbor[0].y;
                if (neighbor[1] < 1.25 * radius) {
                  friends.rx += -(neighbor[0].x - p.x);
                  friends.ry += -(neighbor[0].y - p.y);
                }
              } else {
                numEnemies += 1;
                enemies.mvx += neighbor[0].vx;
                enemies.mvy += neighbor[0].vy;
                enemies.mx += neighbor[0].x;
                enemies.my += neighbor[0].y;
                if (neighbor[1] < 10 * radius) {
                  enemies.rx += -(neighbor[0].x - p.x);
                  enemies.ry += -(neighbor[0].y - p.y);
                }
              }
            }
            if (numFriends > 0) {
              friends.mvx /= numFriends;
              friends.mvy /= numFriends;
              friends.mx /= numFriends;
              friends.my /= numFriends;
            }
            if (numEnemies > 0) {
              enemies.mvx /= numEnemies;
              enemies.mvy /= numEnemies;
              enemies.mx /= numEnemies;
              enemies.my /= numEnemies;
            }
            coefs = [];
            coefs[0] = 1;
            coefs[1] = 1;
            coefs[2] = 5;
            coefs[3] = 1;
            coefs[4] = 1;
            coefs[5] = 2;
            centroidForceX = 0;
            centroidForceY = 0;
            directionForceX = 0;
            directionForceY = 0;
            repulseX = 0;
            repulseY = 0;
            if (numFriends > 0) {
              centroidForceX = coefs[0] * (friends.mx - p.x);
              directionForceX = coefs[1] * friends.mvx;
              repulseX = coefs[4] * friends.rx;
            }
            if (numEnemies > 0) {
              repulseX += coefs[5] * enemies.rx;
            }
            inertiaX = coefs[2] * p.vx;
            randomX = coefs[3] * (Math.random() - 0.5);
            if (numFriends > 0) {
              centroidForceY = coefs[0] * (friends.my - p.y);
              directionForceY = coefs[1] * friends.mvy;
              repulseY = coefs[4] * friends.ry;
            }
            if (numEnemies > 0) {
              repulseY += coefs[5] * enemies.ry;
            }
            inertiaY = coefs[2] * p.vy;
            randomY = coefs[3] * (Math.random() - 0.5);
            p.vx = inertiaX + centroidForceX + directionForceX + randomX + repulseX;
            p.vy = inertiaY + centroidForceY + directionForceY + randomY + repulseY;
            p = setSpeed(p, 2 + (maxNeighbors - numFriends) * 2.0 / maxNeighbors);
            p.x += p.vx;
            p.y += p.vy;
            if (p.x < radius) {
              p.vx = Math.abs(p.vx);
              p.x = radius;
            } else if (p.x > (width - radius)) {
              p.vx = -1 * Math.abs(p.vx);
              p.x = width - radius;
            }
            if (p.y < radius) {
              p.vy = Math.abs(p.vy);
              p.y = radius;
            } else if (p.y > (height - radius)) {
              p.vy = -1 * Math.abs(p.vy);
              p.y = height - radius;
            }
          }
          d3.selectAll('circle').attr('cx', function(d) {
            return d.x;
          }).attr('cy', function(d) {
            return d.y;
          });
          if (nTick % 1 === 0) {
            kdtree = new kdTree(players, distance, ['x', 'y']);
          }
          return shouldWeStop;
        };
        return window.points = players;
      }
    };
  });

}).call(this);
