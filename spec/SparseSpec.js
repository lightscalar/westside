// Generated by CoffeeScript 1.3.3
(function() {

  describe('Sparse Distributed Memory Initialization', function() {
    beforeEach(function() {
      return this.cortex = new Cortex(1000, {
        x: 1,
        y: 1
      }, 5, 0.8, ['x', 'y']);
    });
    it('specifies max number of prototypes', function() {
      return expect(this.cortex.maxPrototypes).toEqual(1000);
    });
    it('specifies the learning rate', function() {
      return expect(this.cortex.learningRate).toEqual(0.8);
    });
    it('specifies the minimum number of locations', function() {
      return expect(this.cortex.minLocs).toEqual(5);
    });
    it('specifies the activation radii', function() {
      return expect(this.cortex.activationRadii).toEqual({
        x: 1,
        y: 1
      });
    });
    it('determines the vector dimension', function() {
      return expect(this.cortex.vectorDimension).toEqual(2);
    });
    return it('saves the state vector dimension labels', function() {
      return expect(this.cortex.dims).toEqual(['x', 'y']);
    });
  });

  describe('Similarity and distance', function() {
    beforeEach(function() {
      return this.cortex = new Cortex(1000, {
        x: 1,
        y: 1
      }, 5, 0.8, ['x', 'y']);
    });
    it('measures similarity between two identical points', function() {
      return expect(this.cortex.similarity({
        x: 5,
        y: 5
      }, {
        x: 5,
        y: 5
      })).toEqual(1);
    });
    it('returns zero for points separated by more than activation radii', function() {
      return expect(this.cortex.similarity({
        x: 10,
        y: 5
      }, {
        x: 5,
        y: 5
      })).toEqual(0);
    });
    it('maps between the two extremes', function() {
      return expect(this.cortex.similarity({
        x: 5.2,
        y: 5.4
      }, {
        x: 5,
        y: 5
      })).toBeCloseTo(0.6, 0.01);
    });
    return it('returns a distance-like measurement as well', function() {
      return expect(this.cortex.triangle({
        x: 5.2,
        y: 5.4
      }, {
        x: 5,
        y: 5
      })).toBeCloseTo(1 / 0.6, 0.01);
    });
  });

  describe('Adding a new state/value pair', function() {
    beforeEach(function() {
      return this.cortex = new Cortex(1000, {
        x: 1,
        y: 1
      }, 3, 0.8, ['x', 'y']);
    });
    it('throws an exception if vector dimensions do not match', function() {
      var _this = this;
      return expect(function() {
        return _this.cortex.add({
          x: 1
        }, 0.4);
      }).toThrow(new Error('Vector dimension must be 2.'));
    });
    it('adds a new prototype', function() {
      this.cortex.add({
        x: 3,
        y: 4
      }, 0.2);
      return expect(this.cortex.prototypes[0]._value).toBeCloseTo(0.2, 0.01);
    });
    it('accommodates addition of multiple state/value pairs', function() {
      this.cortex.add({
        x: 3,
        y: 4
      }, 0.2);
      this.cortex.add({
        x: 4.2,
        y: 6.1
      }, -0.23);
      return expect(this.cortex.nPrototypes).toBeCloseTo(6, 3);
    });
    it('maps values between multiple points', function() {
      this.cortex.add({
        x: 3,
        y: 4
      }, 0.22);
      this.cortex.add({
        x: 3.5,
        y: 4.0
      }, 0.26);
      this.cortex.add({
        x: 3.3,
        y: 4.6
      }, 0.22);
      this.cortex.add({
        x: 3.2,
        y: 4.1
      }, 0.24);
      return expect(this.cortex.predict({
        x: 3.3,
        y: 4.2
      })).toBeCloseTo(0.23, 0.1);
    });
    it('only allows for addition of fixed number of prototypes', function() {
      this.cortex = new Cortex(10, {
        x: 1,
        y: 1
      }, 8, 0.8, ['x', 'y']);
      this.cortex.add({
        x: 3,
        y: 4
      }, 0.2);
      this.cortex.add({
        x: 4.2,
        y: 6.1
      }, -0.23);
      return expect(this.cortex.nPrototypes).toEqual(10);
    });
    return it('handles many dimensions', function() {
      var dims, radii;
      dims = ['x', 'y', 'vx', 'vy', 'theta', 'thrust'];
      radii = {
        x: 5,
        y: 5,
        vx: 1,
        vy: 1,
        theta: 0.5,
        thrust: 0.3
      };
      this.cortex = new Cortex(1000, radii, 5, 0.4, dims);
      return this.cortex.predict({
        x: 100,
        y: 100,
        vx: 32,
        vy: 32,
        theta: 0.23,
        thrust: 0.5
      });
    });
  });

}).call(this);
